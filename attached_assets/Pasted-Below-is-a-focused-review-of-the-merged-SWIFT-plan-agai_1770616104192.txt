Below is a focused review of the merged SWIFT plan against the current codebase, with concrete gaps and potential integration issues. I used the plan in `docs/SWIFT_PROTOCOL_MIGRATION_PLAN.md` and the live server code paths you’re running today.

**Note on code search:** GitHub code search returns at most 10 results, so these may be incomplete. You can view more results in the GitHub UI here: https://github.com/kynomatix/QuantumVault/search?q=swift&type=code

---

## Gaps & potential issues

### 1) **Schema changes in the plan are not in the current schema**
The plan requires new columns for Swift tracking and retry metadata, but the current `bot_trades` and `trade_retry_queue` schemas do not include them.

**Plan expectation (schema additions):**
````markdown name=docs/SWIFT_PROTOCOL_MIGRATION_PLAN.md url=https://github.com/kynomatix/QuantumVault/blob/994941cabef77601d255595078bcce7742624782/docs/SWIFT_PROTOCOL_MIGRATION_PLAN.md#L834-L852
### Step 1: Database Schema Migration

**Changes:**

```
bot_trades table — ADD:
  executionMethod  text  default 'legacy'
  swiftOrderId     text
  auctionDurationMs integer
  priceImprovement  decimal

trade_retry_queue table — ADD:
  swiftAttempts       integer  default 0
  originalExecMethod  text     default 'legacy'
```
````

**Current schema (no Swift fields present):**
````typescript name=shared/schema.ts url=https://github.com/kynomatix/QuantumVault/blob/994941cabef77601d255595078bcce7742624782/shared/schema.ts#L171-L533
export const botTrades = pgTable("bot_trades", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  tradingBotId: varchar("trading_bot_id").notNull().references(() => tradingBots.id, { onDelete: "cascade" }),
  walletAddress: text("wallet_address").notNull().references(() => wallets.address, { onDelete: "cascade" }),
  market: text("market").notNull(),
  side: text("side").notNull(),
  size: decimal("size", { precision: 20, scale: 8 }).notNull(),
  price: decimal("price", { precision: 20, scale: 6 }).notNull(),
  fee: decimal("fee", { precision: 20, scale: 6 }).default("0"),
  pnl: decimal("pnl", { precision: 20, scale: 2 }),
  status: text("status").notNull().default("pending"),
  txSignature: text("tx_signature"),
  webhookPayload: jsonb("webhook_payload"),
  errorMessage: text("error_message"),
  recoveredFromError: text("recovered_from_error"),
  retryAttempts: integer("retry_attempts"),
  executedAt: timestamp("executed_at").defaultNow().notNull(),
});

export const tradeRetryQueue = pgTable("trade_retry_queue", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  originalTradeId: varchar("original_trade_id").notNull(),
  botId: varchar("bot_id").notNull().references(() => tradingBots.id, { onDelete: "cascade" }),
  walletAddress: text("wallet_address").notNull(),
  market: text("market").notNull(),
  side: text("side").notNull(),
  size: decimal("size", { precision: 20, scale: 8 }).notNull(),
  price: decimal("price", { precision: 20, scale: 8 }),
  leverage: integer("leverage").default(1).notNull(),
  priority: text("priority").default("normal").notNull(),
  attempts: integer("attempts").default(0).notNull(),
  maxAttempts: integer("max_attempts").default(5).notNull(),
  cooldownRetries: integer("cooldown_retries").default(0).notNull(),
  nextRetryAt: timestamp("next_retry_at").notNull(),
  lastError: text("last_error"),
  status: text("status").default("pending").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  webhookPayload: jsonb("webhook_payload"),
  entryPrice: decimal("entry_price", { precision: 20, scale: 8 }),
});
````

**Risk:** You won’t be able to record Swift vs legacy execution, Swift order IDs, or Swift retry behavior. This creates audit gaps and prevents the retry service from making Swift-aware decisions.

---

### 2) **`executePerpOrder` has no Swift branch yet**
The plan relies on `executePerpOrder` as the orchestration point, but the current implementation uses SDK or subprocess only (no Swift).

````typescript name=server/drift-service.ts url=https://github.com/kynomatix/QuantumVault/blob/7748b0d13b8ac55fe4293cfbc7a49fcc0a1f819b/server/drift-service.ts#L3243-L3309
export async function executePerpOrder(
  encryptedPrivateKey: string,
  market: string,
  side: 'long' | 'short',
  sizeInBase: number,
  subAccountId: number = 0,
  reduceOnly: boolean = false,
  slippageBps: number = 50,
  privateKeyBase58?: string,
  expectedAgentPubkey?: string,
): Promise<{ success: boolean; signature?: string; txSignature?: string; error?: string; fillPrice?: number; actualFee?: number }> {
  ...
  // Try to use in-process SDK first, fall back to subprocess if SDK not available
  let sdk: any = null;
  let useDriftClient = false;
  ...
  if (useDriftClient && sdk) {
    // Use in-process DriftClient (faster)
    ...
````

**Risk:** The plan assumes Swift-first with legacy fallback, but code still only supports legacy and SDK-based execution. Integration will not be effective until the Swift branch is implemented here.

---

### 3) **Close orders bypass `executePerpOrder` (Swift won’t cover closes yet)**
Subscriber routing and retry logic use `closePerpPosition` directly, so Swift cannot cover close flows unless those calls are reworked.

````typescript name=server/routes.ts url=https://github.com/kynomatix/QuantumVault/blob/994941cabef77601d255595078bcce7742624782/server/routes.ts#L817-L826
const closeResult = await closePerpPosition(
  subWallet.agentPrivateKeyEncrypted,
  subBot.market,
  subAccountId,
  undefined,
  subCloseSlippageBps
);
````

````typescript name=server/trade-retry-service.ts url=https://github.com/kynomatix/QuantumVault/blob/994941cabef77601d255595078bcce7742624782/server/trade-retry-service.ts#L356-L395
if (job.side === 'close') {
  ...
  result = await closePerpPosition(
    job.agentPrivateKeyEncrypted,
    job.market,
    job.subAccountId,
    undefined,
    job.slippageBps
  );
}
````

**Risk:** Even after Swift integration for opens, close orders will still be legacy-only. That contradicts the plan’s intent to cover all execution paths and will skew metrics/fee logic.

---

### 4) **Subscriber-close PnL uses signal price, not actual fill**
If Swift is used, fills are asynchronous and can be better/worse than the signal price. The subscriber close path uses the signal price regardless of actual fill.

````typescript name=server/routes.ts url=https://github.com/kynomatix/QuantumVault/blob/994941cabef77601d255595078bcce7742624782/server/routes.ts#L827-L846
if (closeResult.success) {
  const fillPrice = parseFloat(signal.price);
  ...
  const closeNotional = Math.abs(position.size) * fillPrice;
  const closeFee = closeNotional * 0.00045;
  ...
  if (closeEntryPrice > 0 && fillPrice > 0) {
    if (position.side === 'LONG') {
      closeTradePnl = (fillPrice - closeEntryPrice) * Math.abs(position.size) - closeFee;
    } else {
      closeTradePnl = (closeEntryPrice - fillPrice) * Math.abs(position.size) - closeFee;
    }
  }
}
````

**Risk:** Profit share and realized PnL can be wrong if Swift’s fill price differs from the signal price. This is especially likely because Swift uses auctions.

---

### 5) **Retry logic is not Swift-aware**
The plan requires Swift-specific retry attempts and classification. The current retry service only understands RPC/timeout/transient errors.

````typescript name=server/trade-retry-service.ts url=https://github.com/kynomatix/QuantumVault/blob/994941cabef77601d255595078bcce7742624782/server/trade-retry-service.ts#L65-L209
export function isRateLimitError(...)
export function isTransientError(...)
export function isTimeoutError(...)
export function categorizeError(...)
````

**Risk:** Swift API errors (“no liquidity”, “auction timeout”, “stale slot”) will be treated as generic transient errors, causing incorrect retry/fallback behavior and potentially unnecessary cooldowns.

---

## Summary: priority gaps to close before integrating the plan
1. **Schema migration** for Swift fields (plan expects them; schema doesn’t have them).
2. **Swift orchestration in `executePerpOrder`** (not yet implemented).
3. **Close paths** still bypass Swift (`closePerpPosition` used directly).
4. **Subscriber-close PnL** uses signal price, not fill price.
5. **Retry logic** lacks Swift error classification and Swift retry counters.

---

If you want, I can:
- Produce a targeted checklist per file (routes, drift-service, trade-retry, schema).
- Propose concrete implementation changes (no PR unless you ask).
- Run a deeper scan of the rest of the webhook/manual flows for similar Swift gaps.