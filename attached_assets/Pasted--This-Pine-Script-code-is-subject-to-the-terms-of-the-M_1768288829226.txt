// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © Kryptolytix - OI/Funding Rate Scalper V2 for QuantumVault
// Designed for LTF crypto perpetuals (1m-5m) on liquid pairs (BTC, ETH, SOL)
// Auto-detects base currency from chart

//@version=6
strategy("OI/Funding Scalper V2 [QuantumVault]", 
     overlay=true, 
     initial_capital=10000,
     default_qty_type=strategy.percent_of_equity,
     default_qty_value=10,
     commission_type=strategy.commission.percent,
     commission_value=0.05,
     slippage=2,
     process_orders_on_close=false,
     calc_on_every_tick=false,
     margin_long=10,
     margin_short=10)

// ============================================================================
// INPUTS
// ============================================================================

// === Data Source Settings ===
string dataGroup = "Data Sources"
string oiExchange = input.string("BINANCE", "OI Exchange", options=["BINANCE", "BYBIT", "OKX"], group=dataGroup)
string fundingExchange = input.string("BINANCE", "Funding Exchange", options=["BINANCE", "BYBIT"], group=dataGroup)
bool autoDetectSymbol = input.bool(true, "Auto-Detect Symbol from Chart", group=dataGroup)
string manualBase = input.string("SOL", "Manual Base Currency (if auto-detect off)", group=dataGroup)
bool useExternalOI = input.bool(true, "Use External OI Data", group=dataGroup)
bool useExternalFunding = input.bool(true, "Use External Funding Data", group=dataGroup)

// === Funding Rate Settings ===
string fundingGroup = "Funding Rate"
float fundingExtreme = input.float(0.001, "Funding Rate Extreme (%)", minval=0.0001, maxval=0.5, step=0.001, group=fundingGroup,
     tooltip="Absolute funding rate above this = extreme")
float fundingModerate = input.float(0.01, "Funding Rate Moderate (%)", minval=0.001, maxval=0.2, step=0.001, group=fundingGroup)
int fundingLookback = input.int(50, "Funding Lookback (bars)", minval=5, maxval=100, group=fundingGroup)

// === Open Interest Settings ===
string oiGroup = "Open Interest"
int oiLookback = input.int(42, "OI Lookback Period", minval=10, maxval=200, group=oiGroup)
float oiSpikeThreshold = input.float(1.75, "OI Spike StdDev Threshold", minval=1.0, maxval=5.0, step=0.25, group=oiGroup)
float oiDropThreshold = input.float(-1.5, "OI Drop StdDev Threshold", minval=-5.0, maxval=-0.5, step=0.25, group=oiGroup)

// === Context Detection Settings ===
string contextGroup = "Context Detection"
int extendedMoveLookback = input.int(9, "Extended Move Lookback", minval=5, maxval=100, group=contextGroup)
float extendedMoveATRMult = input.float(1.0, "Extended Move ATR Multiple", minval=0.5, maxval=10.0, step=0.5, group=contextGroup)
int consolidationBars = input.int(9, "Consolidation Detection Bars", minval=3, maxval=50, group=contextGroup)
float consolidationATRMult = input.float(1.0, "Consolidation ATR Multiple", minval=0.25, maxval=3.0, step=0.25, group=contextGroup)

// === Volatility Regime Filter ===
string volGroup = "Volatility Regime"
int atrPeriod = input.int(29, "ATR Period", minval=5, maxval=50, group=volGroup)
float volMinPercentile = input.float(22.0, "Min Volatility Percentile", minval=0.0, maxval=50.0, group=volGroup)
float volMaxPercentile = input.float(90.0, "Max Volatility Percentile", minval=50.0, maxval=100.0, group=volGroup)
int volLookback = input.int(100, "Volatility Lookback", minval=20, maxval=500, group=volGroup)

// === VWAP Settings ===
string vwapGroup = "VWAP Confluence"
bool useVWAP = input.bool(true, "Use VWAP Confluence", group=vwapGroup)
float vwapDeviation = input.float(1.0, "VWAP Deviation Threshold", minval=0.5, maxval=4.0, step=0.25, group=vwapGroup)

// === Risk Management ===
string riskGroup = "Risk Management"
float tpPercent = input.float(1.75, "Take Profit %", minval=0.1, maxval=5.0, step=0.05, group=riskGroup)
float slPercent = input.float(1.0, "Stop Loss %", minval=0.05, maxval=3.0, step=0.05, group=riskGroup)
bool useTrailingTP = input.bool(true, "Use Trailing Take Profit", group=riskGroup)
float trailActivation = input.float(1.0, "Trail Activation %", minval=0.05, maxval=3.0, step=0.05, group=riskGroup)
float trailOffset = input.float(0.02, "Trail Offset %", minval=0.01, maxval=0.5, step=0.01, group=riskGroup)
int maxTradesPerHour = input.int(10, "Max Trades Per Hour", minval=1, maxval=20, group=riskGroup)
float minScoreToTrade = input.float(6.0, "Minimum Signal Score", minval=1.0, maxval=15.0, group=riskGroup)

// === Session Filter ===
string sessionGroup = "Session Filter"
bool useSessionFilter = input.bool(false, "Use Session Filter", group=sessionGroup)
string activeSession = input.session("0000-2359", "Active Trading Hours (UTC)", group=sessionGroup)

// ============================================================================
// SYMBOL DETECTION & DATA FETCHING
// ============================================================================

// Auto-detect base currency from chart
string baseCurrency = autoDetectSymbol ? syminfo.basecurrency : manualBase

// Construct OI ticker - Format: EXCHANGE:BASEUSDT.P_OI
string oiTicker = oiExchange + ":" + baseCurrency + "USDT.P_OI"

// Construct Funding ticker - Format: EXCHANGE:BASEUSDTPERP
string fundingTicker = fundingExchange + ":" + baseCurrency + "USDTPERP"

// Fetch Open Interest data
float rawOI = useExternalOI ? request.security(oiTicker, timeframe.period, close, ignore_invalid_symbol=true) : na
bool oiDataValid = not na(rawOI) and rawOI > 0

// Fetch Funding Rate - Try multiple approaches
// Note: Funding rate data availability varies by exchange
float rawFunding = na
if useExternalFunding
    // Try perp symbol directly (some data providers embed funding in this)
    rawFunding := request.security(fundingTicker, timeframe.period, close, ignore_invalid_symbol=true)

bool fundingDataValid = not na(rawFunding)

// Use chart volume as OI proxy if external data unavailable
float volumeProxy = ta.sma(volume * close, 20)  // Dollar volume as proxy
float effectiveOI = oiDataValid ? rawOI : volumeProxy
float fundingRate = fundingDataValid ? rawFunding : 0.0

// ============================================================================
// CORE CALCULATIONS
// ============================================================================

// --- Volatility Regime ---
float atr = ta.atr(atrPeriod)
float atrPercent = (atr / close) * 100

// Calculate ATR percentile
float atrPercentile = 0.0
int atrRank = 0
for i = 0 to volLookback - 1
    if atrPercent > atrPercent[i]
        atrRank += 1
atrPercentile := (atrRank / volLookback) * 100

bool volRegimeOK = atrPercentile >= volMinPercentile and atrPercentile <= volMaxPercentile

// --- Open Interest Analysis ---
float oiChange = effectiveOI - effectiveOI[1]
float oiChangePercent = effectiveOI[1] != 0 ? (oiChange / effectiveOI[1]) * 100 : 0

// OI change statistics
float oiChangeMean = ta.sma(oiChange, oiLookback)
float oiChangeStdDev = ta.stdev(oiChange, oiLookback)
float oiZScore = oiChangeStdDev != 0 ? (oiChange - oiChangeMean) / oiChangeStdDev : 0

// OI signals
bool oiSpike = oiZScore > oiSpikeThreshold
bool oiDrop = oiZScore < oiDropThreshold
bool oiNeutral = not oiSpike and not oiDrop

// --- Funding Rate Analysis ---
// Note: If using price as proxy, this won't work - need actual funding data
float fundingAbs = math.abs(fundingRate)
bool fundingExtremeHigh = fundingRate > fundingExtreme
bool fundingExtremeLow = fundingRate < -fundingExtreme
bool fundingModerateHigh = fundingRate > fundingModerate and not fundingExtremeHigh
bool fundingModerateLow = fundingRate < -fundingModerate and not fundingExtremeLow

// Funding rate percentile
float fundingPercentile = 0.0
int fundingRank = 0
for i = 0 to fundingLookback - 1
    if fundingRate > fundingRate[i]
        fundingRank += 1
fundingPercentile := (fundingRank / fundingLookback) * 100

// --- Context Detection ---
// Extended move detection
float priceMove = close - close[extendedMoveLookback]
float priceMoveATR = atr * extendedMoveATRMult
bool extendedMoveUp = priceMove > priceMoveATR
bool extendedMoveDown = priceMove < -priceMoveATR
bool afterExtendedMove = extendedMoveUp or extendedMoveDown

// Consolidation detection
float rangeHigh = ta.highest(high, consolidationBars)
float rangeLow = ta.lowest(low, consolidationBars)
float priceRange = rangeHigh - rangeLow
float consolidationThreshold = atr * consolidationATRMult
bool isConsolidating = priceRange < consolidationThreshold

// --- VWAP Calculation ---
var float vwapSum = 0.0
var float volSum = 0.0
var float vwap = 0.0
var float vwapSqSum = 0.0

bool newSession = ta.change(time("D")) != 0
if newSession
    vwapSum := 0.0
    volSum := 0.0
    vwapSqSum := 0.0

float typicalPrice = hlc3
vwapSum += typicalPrice * volume
volSum += volume
vwapSqSum += typicalPrice * typicalPrice * volume

vwap := volSum != 0 ? vwapSum / volSum : close
float vwapVariance = volSum != 0 ? (vwapSqSum / volSum) - (vwap * vwap) : 0
float vwapStdDev = math.sqrt(math.max(vwapVariance, 0))
float vwapDev = vwapStdDev != 0 ? (close - vwap) / vwapStdDev : 0

bool priceAboveVWAP = vwapDev > vwapDeviation
bool priceBelowVWAP = vwapDev < -vwapDeviation
bool vwapConfirmLong = priceBelowVWAP or not useVWAP
bool vwapConfirmShort = priceAboveVWAP or not useVWAP

// --- Liquidation Cascade Detection ---
bool liquidationCascadeLong = oiDrop and (close < close[1])
bool liquidationCascadeShort = oiDrop and (close > close[1])
bool postLiquidationFlush = oiDrop[3] and not oiDrop and oiNeutral

// ============================================================================
// SIGNAL GENERATION
// ============================================================================

var float longScore = 0.0
var float shortScore = 0.0

longScore := 0.0
shortScore := 0.0

// Funding Rate Signals (Contrarian) - Only if we have valid funding data
if fundingDataValid
    if fundingExtremeHigh
        shortScore += 3.0
    else if fundingModerateHigh
        shortScore += 1.5
    
    if fundingExtremeLow
        longScore += 3.0
    else if fundingModerateLow
        longScore += 1.5

// OI Signals (Context Dependent)
if oiSpike
    if afterExtendedMove
        if extendedMoveUp
            shortScore += 2.5  // Exhaustion after up move
        else if extendedMoveDown
            longScore += 2.5   // Exhaustion after down move
    else if isConsolidating
        // Breakout building - wait for direction confirmation
        if close > close[1] and close > open
            longScore += 1.5   // Bullish breakout building
        else if close < close[1] and close < open
            shortScore += 1.5  // Bearish breakout building
    else
        // OI spike in trending market without extreme move
        // This catches accumulation/distribution
        if close > ta.sma(close, 20)
            shortScore += 1.0  // Late longs piling in above MA
        else
            longScore += 1.0   // Late shorts piling in below MA

// OI Drop (Liquidation Cascade) - Continuation signals
if liquidationCascadeLong
    shortScore += 2.0  // Longs getting liquidated, continue short
else if liquidationCascadeShort
    longScore += 2.0   // Shorts getting liquidated, continue long

// Post-Liquidation Reversal - Mean reversion after flush
if postLiquidationFlush
    float sma10 = ta.sma(close, 10)
    float sma20 = ta.sma(close, 20)
    // More nuanced reversal detection
    if close < sma10 and close < sma20
        longScore += 2.5   // Oversold after flush - reversal long
    else if close > sma10 and close > sma20
        shortScore += 2.5  // Overbought after flush - reversal short
    else
        // Price between MAs - weaker signal
        if close < sma10
            longScore += 1.5
        else
            shortScore += 1.5

// === PRICE ACTION SIGNALS (Always active - not just fallback) ===
// These provide balance to OI-heavy short signals
float rsi = ta.rsi(close, 14)
float volSMA = ta.sma(volume, 20)
bool volSpike = volume > volSMA * 1.5

// VWAP Confluence - Now independent, not requiring existing score
// Extreme VWAP deviations are signals on their own
if priceBelowVWAP
    longScore += 1.5   // Mean reversion opportunity
if priceAboveVWAP
    shortScore += 1.5  // Mean reversion opportunity

// Extra confluence when VWAP aligns with other signals
if priceBelowVWAP and rsi < 40
    longScore += 0.5
if priceAboveVWAP and rsi > 60
    shortScore += 0.5

// RSI extremes - independent long/short triggers
if rsi < 30
    longScore += 2.0
    if priceBelowVWAP
        longScore += 0.5  // Extra confluence
if rsi > 70
    shortScore += 2.0
    if priceAboveVWAP
        shortScore += 0.5

// Volume spike reversals
if volSpike
    // Bullish rejection candle (long lower wick, close near high)
    float bodySize = math.abs(close - open)
    float lowerWick = math.min(open, close) - low
    float upperWick = high - math.max(open, close)
    
    if lowerWick > bodySize * 1.5 and close > open
        longScore += 1.5  // Hammer pattern
    if upperWick > bodySize * 1.5 and close < open
        shortScore += 1.5  // Shooting star pattern

// Momentum divergence (price vs RSI)
float rsiSMA = ta.sma(rsi, 14)
bool rsiOversold = rsi < 35 and rsi > rsi[1] and close < close[1]  // Bullish divergence hint
bool rsiOverbought = rsi > 65 and rsi < rsi[1] and close > close[1]  // Bearish divergence hint

if rsiOversold
    longScore += 1.0
if rsiOverbought
    shortScore += 1.0

// --- Final Signal Determination ---
bool longSignal = longScore >= minScoreToTrade
bool shortSignal = shortScore >= minScoreToTrade

// ============================================================================
// TRADE FREQUENCY LIMITER
// ============================================================================

var int tradesThisHour = 0
var int lastTradeHour = hour

if hour != lastTradeHour
    tradesThisHour := 0
    lastTradeHour := hour

bool canTradeFrequency = tradesThisHour < maxTradesPerHour

// ============================================================================
// SESSION FILTER
// ============================================================================

bool inSession = useSessionFilter ? not na(time(timeframe.period, activeSession)) : true

// ============================================================================
// FINAL ENTRY CONDITIONS
// ============================================================================

bool canTrade = volRegimeOK and canTradeFrequency and inSession and barstate.isconfirmed

bool enterLong = canTrade and longSignal and not shortSignal and strategy.position_size == 0
bool enterShort = canTrade and shortSignal and not longSignal and strategy.position_size == 0

// ============================================================================
// STRATEGY EXECUTION
// ============================================================================

if enterLong
    strategy.entry("Long", strategy.long)
    tradesThisHour += 1
    alert("LONG | Score: " + str.tostring(longScore, "#.##") + " | " + baseCurrency, alert.freq_once_per_bar_close)

if enterShort
    strategy.entry("Short", strategy.short)
    tradesThisHour += 1
    alert("SHORT | Score: " + str.tostring(shortScore, "#.##") + " | " + baseCurrency, alert.freq_once_per_bar_close)

// Exit Management
float longTP = strategy.position_avg_price * (1 + tpPercent / 100)
float longSL = strategy.position_avg_price * (1 - slPercent / 100)
float shortTP = strategy.position_avg_price * (1 - tpPercent / 100)
float shortSL = strategy.position_avg_price * (1 + slPercent / 100)

if strategy.position_size > 0
    if useTrailingTP
        strategy.exit("Long Exit", "Long", 
             limit=longTP, 
             stop=longSL,
             trail_price=strategy.position_avg_price * (1 + trailActivation / 100),
             trail_offset=math.round(close * (trailOffset / 100) / syminfo.mintick))
    else
        strategy.exit("Long Exit", "Long", limit=longTP, stop=longSL)

if strategy.position_size < 0
    if useTrailingTP
        strategy.exit("Short Exit", "Short", 
             limit=shortTP, 
             stop=shortSL,
             trail_price=strategy.position_avg_price * (1 - trailActivation / 100),
             trail_offset=math.round(close * (trailOffset / 100) / syminfo.mintick))
    else
        strategy.exit("Short Exit", "Short", limit=shortTP, stop=shortSL)

// ============================================================================
// VISUALIZATION
// ============================================================================

// --- Data Status & Signal Score Display ---
var table infoTable = table.new(position.top_right, 2, 12, bgcolor=color.new(color.black, 80))

if barstate.islast
    // Data status
    table.cell(infoTable, 0, 0, "Base Currency", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 0, baseCurrency, text_color=color.yellow, text_size=size.small)
    
    table.cell(infoTable, 0, 1, "OI Data", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 1, oiDataValid ? "✓ OK" : "✗ Using Proxy", 
         text_color=oiDataValid ? color.lime : color.orange, text_size=size.small)
    
    table.cell(infoTable, 0, 2, "Funding Data", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 2, fundingDataValid ? "✓ OK" : "✗ N/A", 
         text_color=fundingDataValid ? color.lime : color.red, text_size=size.small)
    
    table.cell(infoTable, 0, 3, "─────────", text_color=color.gray, text_size=size.small)
    table.cell(infoTable, 1, 3, "─────────", text_color=color.gray, text_size=size.small)
    
    // Scores
    table.cell(infoTable, 0, 4, "Long Score", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 4, str.tostring(longScore, "#.##"), 
         text_color=longScore >= minScoreToTrade ? color.lime : color.gray, text_size=size.small)
    
    table.cell(infoTable, 0, 5, "Short Score", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 5, str.tostring(shortScore, "#.##"), 
         text_color=shortScore >= minScoreToTrade ? color.red : color.gray, text_size=size.small)
    
    // Key metrics
    table.cell(infoTable, 0, 6, "Funding", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 6, fundingDataValid ? str.tostring(fundingRate * 100, "#.####") + "%" : "N/A", 
         text_color=fundingExtremeHigh ? color.red : fundingExtremeLow ? color.lime : color.gray, text_size=size.small)
    
    table.cell(infoTable, 0, 7, "OI Z-Score", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 7, str.tostring(oiZScore, "#.##"), 
         text_color=oiSpike ? color.yellow : oiDrop ? color.orange : color.gray, text_size=size.small)
    
    table.cell(infoTable, 0, 8, "Vol Regime", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 8, volRegimeOK ? "OK (" + str.tostring(atrPercentile, "#") + "%)" : "SKIP", 
         text_color=volRegimeOK ? color.lime : color.red, text_size=size.small)
    
    table.cell(infoTable, 0, 9, "Context", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 9, afterExtendedMove ? "Extended" : isConsolidating ? "Consol" : "Normal", 
         text_color=color.white, text_size=size.small)
    
    table.cell(infoTable, 0, 10, "VWAP Dev", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 10, str.tostring(vwapDev, "#.##") + "σ", 
         text_color=priceAboveVWAP ? color.red : priceBelowVWAP ? color.lime : color.gray, text_size=size.small)
    
    table.cell(infoTable, 0, 11, "Trades/Hr", text_color=color.white, text_size=size.small)
    table.cell(infoTable, 1, 11, str.tostring(tradesThisHour) + "/" + str.tostring(maxTradesPerHour), 
         text_color=canTradeFrequency ? color.lime : color.red, text_size=size.small)

// --- Plot VWAP ---
plot(vwap, "VWAP", color=color.new(color.yellow, 30), linewidth=2)
plot(vwap + vwapStdDev * vwapDeviation, "VWAP Upper", color=color.new(color.red, 60), linewidth=1)
plot(vwap - vwapStdDev * vwapDeviation, "VWAP Lower", color=color.new(color.lime, 60), linewidth=1)

// --- Plot OI (scaled to price) ---
float oiScaled = oiDataValid ? (effectiveOI / ta.sma(effectiveOI, 50)) * close * 0.95 : na
plot(oiScaled, "OI (scaled)", color=color.new(color.purple, 50), linewidth=1, style=plot.style_stepline)

// --- Signal Markers ---
plotshape(enterLong, "Long Entry", shape.triangleup, location.belowbar, color.lime, size=size.small)
plotshape(enterShort, "Short Entry", shape.triangledown, location.abovebar, color.red, size=size.small)

// --- Background Colors ---
bgcolor(oiSpike ? color.new(color.yellow, 90) : na, title="OI Spike")
bgcolor(oiDrop ? color.new(color.orange, 90) : na, title="OI Drop (Liquidations)")
bgcolor(fundingExtremeHigh ? color.new(color.red, 95) : fundingExtremeLow ? color.new(color.lime, 95) : na, title="Funding Extreme")

// ============================================================================
// DEBUG: Log data source info
// ============================================================================
if barstate.isfirst
    log.info("OI Ticker: " + oiTicker)
    log.info("Funding Ticker: " + fundingTicker)
    log.info("Base Currency: " + baseCurrency)

// ============================================================================
// ALERTS
// ============================================================================

alertcondition(enterLong, "Long Entry Signal", "OI/Funding Scalper: LONG Entry")
alertcondition(enterShort, "Short Entry Signal", "OI/Funding Scalper: SHORT Entry")
alertcondition(oiSpike, "OI Spike Detected", "Open Interest Spike Detected")
alertcondition(oiDrop, "Liquidation Cascade", "Liquidation Cascade Detected")
alertcondition(fundingExtremeHigh or fundingExtremeLow, "Funding Extreme", "Funding Rate at Extreme Level")
