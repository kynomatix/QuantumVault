This v2 plan is much closer to modern standards. The primitives and the envelope pattern are on the right track. There are still a few **spec level contradictions** and two **design gaps** that will bite you in production if you do not tighten them now.

Below is a hard, security engineer style review: what is solid, what must change, and what is optional hardening.

---

## What is now up to scratch

### Envelope encryption with UMK

This is the correct architecture. Stable UMK, rewrap UMK per session, no mass re encryption.

### Purpose bound signatures, domain binding, cluster binding

This is the right direction to reduce phishing and replay.

### AES 256 GCM pinned parameters

Good. 12 byte IV, 16 byte tag, AAD required.

### Nonce table and replay prevention

Good. Storing nonce hash server side with expiry is the right model.

### Execution authorization plus bot policy limits

This is essential for headless webhooks and reduces catastrophic loss from bot bugs.

---

## Critical issues to fix before calling it production grade

### 1) Your signature message is contradictory

In the diagram you say:

> “Sign deterministic message for key derivation”
> "QuantumVault:Unlock:{wallet_address}"

But later you require nonce, issuedAt, expiresAt in every signed message. Those are not deterministic.

You should **not** use a deterministic unlock message anyway. A deterministic message produces a stable signature in many ed25519 implementations, which increases phishing risk because the user might be tricked into signing the same unlock string elsewhere.

Fix:

* Delete the deterministic message concept completely.
* Always sign a structured payload that includes nonce and expiry.

Practical rule:

* Every privileged signature must be unique because of a fresh nonce.

---

### 2) Nonce rules conflict with your TTL table

You say:

* Nonce single use, each nonce valid for one signature only
  But your table says:
* unlock_umk single use: No

That is a problem.

Fix:

* Every nonce should be single use, always, for every purpose.
* If you want unlock to be valid for 24h, that is session TTL, not nonce reuse.

Correct model:

* You mint a nonce, user signs it once, you mark nonce used.
* You create a server session that stays valid for up to 24h.

---

### 3) Execution Key flow is underspecified and currently inconsistent

Right now you have:

* agent private key encrypted with key_privkey derived from UMK
* EK derived from UMK and wrapped with SERVER_EXECUTION_KEY
* webhook decrypts EK and then “Use EK to decrypt agent private key”

But EK cannot decrypt the agent private key if the private key is encrypted under key_privkey unless you explicitly re encrypt something during enable_execution.

You need to pick one of these designs:

#### Design A, wrap UMK for execution

On enable_execution:

* unwrap UMK using SK
* wrap UMK with SERVER_EXECUTION_KEY into EUMK_exec
* store EUMK_exec with expiry
  On webhook:
* unwrap UMK from EUMK_exec
* derive key_privkey
* decrypt agent private key

This is the simplest and cleanest.

#### Design B, wrap key_privkey for execution

On enable_execution:

* unwrap UMK
* derive key_privkey
* wrap key_privkey with SERVER_EXECUTION_KEY as EPrivKeyKey_exec
  On webhook:
* unwrap key_privkey
* decrypt agent private key

This is fine too, but less general than wrapping UMK.

#### Design C, re encrypt agent private key under EK

On enable_execution:

* decrypt agent private key using key_privkey
* encrypt it under EK and store EAgentPrivKey_exec
  On webhook:
* decrypt using EK

This increases complexity and doubles stored ciphertext, but is workable.

Recommendation:

* Use Design A. Wrap UMK for execution.

---

### 4) Your AAD encoding should not be JSON

Using JSON.stringify for AAD can introduce subtle issues:

* key ordering
* whitespace differences
* accidental changes across runtimes
* future migrations can break decryption if you change formatting

Fix:
Use a stable binary encoding. Example:

* version as u32 LE
* recordType as a short fixed string or u8 enum
* wallet pubkey bytes as 32 bytes

Do not use JSON for cryptographic binding.

---

## High priority hardening I strongly recommend

### 5) SK derivation should bind to the signed payload, not just signature

Right now:

* ikm = walletAddress + signature

Better:

* derive SK from signature plus the canonical signed message bytes, plus wallet address
* include purpose and expiresAt in the HKDF info

This prevents any weird edge cases where the same signature bytes could ever be accepted for different contexts.

---

### 6) Session security needs explicit web app controls

Your plan focuses on crypto, but modern security standards require basic web session hygiene:

* httpOnly secure cookies
* SameSite=Lax or Strict
* CSRF protection if you use cookies
* session id rotation after unlock
* rate limiting on unlock and enable_execution endpoints
* IP and device fingerprint anomaly detection for mnemonic reveal

These are not optional if you are handling keys.

---

### 7) Memory zeroization expectations in Node.js

You are doing the right thing by keeping keys in Buffers and zeroizing, but be aware:

* JS strings cannot be reliably zeroized
* GC is nondeterministic
* crypto.randomFillSync then fill(0) is ok, but you cannot guarantee copies were not made

Practical fixes:

* Keep secrets in Buffer form end to end
* Avoid base58 strings for private keys inside server logic
* If you must pass to executor, pass as Uint8Array bytes, not base58 string

---

## Threat model reality check

### If attacker gets DB only

Your v2 is strong. Without server execution key or a valid user session, ciphertext is useless.

### If attacker gets server execution key plus DB

They can decrypt active execution wrapped UMKs and trade until expiry.

Mitigations you already have:

* expiry
* revoke
* bot risk limits
* kill switch

Additional mitigation I recommend:

* short default execution window like 15 minutes to 1 hour, not 24 hours
* require explicit re enable for long running bots
* per bot max notional and daily loss enforced server side before signing any tx

---

## Mnemonic derivation

Your Solana path is correct in spirit, but validate the library outputs. Solana uses ed25519 and common practice is m/44'/501'/0'/0'. Your use of ed25519-hd-key plus Keypair.fromSeed can be correct, but you must confirm:

* derivedSeed is exactly 32 bytes
* it matches expected Solana keypairs from the same mnemonic as Phantom would generate for that path

If this does not match Phantom derivations, you will confuse users during recovery.

---

## Verdict

v2 is broadly aligned with modern standards, but I would not ship until you fix:

1. Remove deterministic unlock message concept
2. Make nonces single use for every purpose
3. Clarify execution flow by wrapping UMK for execution or re encrypting a dedicated exec secret
4. Replace JSON AAD with stable binary AAD encoding

If you want, paste the exact encryption and storage functions you plan to implement, and I will rewrite the crypto interface as a tight spec Replit can implement without interpretation errors, including the execution wrapped UMK design and binary AAD layout.
