Thanks for the commit list ‚Äî I reviewed the **latest commit `7100350`** against the audited plan. Below are the most likely causes of **‚Äúorders accepted but not filled / MMs not picking up‚Äù**, based on the actual implementation.

---

# ‚úÖ High‚Äëconfidence issues (likely blocking fills)

## 1) **Swift API `message` is not base64‚Äëencoded**
Swift expects the signed order params **base64‚Äëencoded**, but the current payload sends a UTF‚Äë8 string of the buffer instead.

````typescript name=server/swift-executor.ts url=https://github.com/kynomatix/QuantumVault/blob/7100350e61f43c2ca483cc6a0d704c49bad7aa7d/server/swift-executor.ts#L139-L153
const body = {
  market_index: params.marketIndex,
  market_type: 'perp',
  message: params.orderParams.toString(),
  signature: Buffer.from(params.signature).toString('base64'),
  taker_authority: params.takerAuthority,
};
````

**Fix:**  
Use `params.orderParams.toString('base64')` here.  
This alone can cause Swift to accept the request but **MMs ignore it**.

---

## 2) **Oracle price missing ‚Üí auction prices = 0**
If oracle price is missing, you send **auctionStartPrice/EndPrice/limitPrice = 0**, which is invalid and will never fill.

````typescript name=server/swift-executor.ts url=https://github.com/kynomatix/QuantumVault/blob/7100350e61f43c2ca483cc6a0d704c49bad7aa7d/server/swift-executor.ts#L56-L83
if (!params.oraclePrice || params.oraclePrice <= 0) {
  return { auctionDuration: 20, auctionStartPrice: new BN(0), auctionEndPrice: new BN(0), limitPrice: new BN(0) };
}
````

**Fix:**  
If `oraclePrice` is missing, **skip Swift and fallback immediately**, or fetch a price before building the order.

---

## 3) **`agentPublicKey` is passed but unused**
`executeSwiftOrder` takes `agentPublicKey`, but request uses the keypair‚Äôs pubkey.  
If any caller passes a mismatched key (UMK vs legacy), Swift could sign with a key **that doesn‚Äôt match the intended taker**.

````typescript name=server/swift-executor.ts url=https://github.com/kynomatix/QuantumVault/blob/7100350e61f43c2ca483cc6a0d704c49bad7aa7d/server/swift-executor.ts#L225-L231
const response = await submitToSwiftApi({
  orderParams: signed.orderParams,
  signature: signed.signature,
  takerAuthority: keypair.publicKey.toBase58(),
  marketIndex: params.marketIndex,
});
````

**Fix (safety):**  
Use `params.agentPublicKey` and log if it doesn‚Äôt match the derived keypair.

---

# ‚úÖ Things that look correct
- **Swift‚Äëfirst orchestration** appears wired in `drift-service.ts`
- **Min notional gating** is in `swift-config.ts`
- **Metrics module** exists and is wired
- **Retry worker** is Swift‚Äëaware (tracks `swiftAttempts`, `originalExecMethod`)

---

# üîç Immediate debug checklist (fastest signal)

1) Check **`/tmp/swift-debug.log`**  
You log **Swift API status + response body** there.

2) Force one test trade **above SWIFT_MIN_NOTIONAL**  
(Use $100+ and known liquid market, e.g., SOL‚ÄëPERP)

3) Confirm **oracle price is non‚Äëzero** in logs  
If oracle price = 0, Swift will never fill.

---

# If you want, I can do this next
I can:
- pinpoint the exact Swift check block in `drift-service.ts`
- trace how `oraclePrice` is derived + where it can be null
- confirm all close paths pass position size + side correctly

Just say the word and I‚Äôll drill further.