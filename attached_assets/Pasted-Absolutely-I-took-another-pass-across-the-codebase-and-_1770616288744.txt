Absolutely — I took another pass across the codebase and the plan. Here are **additional gaps / potential issues** beyond the first batch, with concrete file references for reporting.

---

## Additional gaps & integration risks

### 1) **Fee model mismatch (Swift “gasless” vs current fee accounting)**
The plan states Swift trades are gasless, but the legacy executor still estimates a fee and downstream PnL/fee logic assumes that value is real.

````javascript name=server/drift-executor.mjs url=https://github.com/kynomatix/QuantumVault/blob/994941cabef77601d255595078bcce7742624782/server/drift-executor.mjs#L1395-L1410
// Estimate fee: 0.05% base - 10% referral discount = 0.045%
if (fillPrice) {
  const notional = fillPrice * sizeInBase;
  actualFee = notional * 0.00045;
  console.error(`[Executor] Estimated fee (with referral): $${actualFee?.toFixed(6) || 'unknown'}`);
}
````

**Risk:** If Swift truly shifts fees or subsidizes them, PnL and profit share math will be skewed unless Swift provides actual fee metadata and those fields are stored.

---

### 2) **Swift expects `executePerpOrder` routing everywhere, but close paths still bypass it**
Plan says all execution flows route through `executePerpOrder`, but close orders still call `closePerpPosition` directly.

````typescript name=server/trade-retry-service.ts url=https://github.com/kynomatix/QuantumVault/blob/994941cabef77601d255595078bcce7742624782/server/trade-retry-service.ts#L356-L395
if (job.side === 'close') {
  ...
  result = await closePerpPosition(
    job.agentPrivateKeyEncrypted,
    job.market,
    job.subAccountId,
    undefined,
    job.slippageBps
  );
}
````

**Risk:** Swift will only cover opens unless the close flow is consolidated or Swift close support is added separately.

---

### 3) **Swift error classification has no landing zone in current retry service**
The plan defines `retry_swift`, `fallback_legacy`, and `permanent` classifications, but the current retry logic only understands generic transient/timeout errors.

````typescript name=server/trade-retry-service.ts url=https://github.com/kynomatix/QuantumVault/blob/994941cabef77601d255595078bcce7742624782/server/trade-retry-service.ts#L82-L108
export function isTimeoutError(error: string | Error | unknown): boolean {
  const errorStr = error instanceof Error ? error.message : String(error);
  const lowerError = errorStr.toLowerCase();
  return (
    lowerError.includes('timeout') ||
    lowerError.includes('timed out') ||
    lowerError.includes('timeout_subprocess') ||
    lowerError.includes('timeout_trade') ||
    lowerError.includes('timeout_close')
  );
}
````

**Risk:** Swift-specific failures (stale slot, auction expiry, no liquidity) won’t route correctly. Some should trigger Swift retry; others should instantly fall back to legacy.

---

### 4) **`executePerpOrder` still assumes only SDK/subprocess paths**
Even after adding Swift, the orchestration needs to be inserted in this function, but today it only tries in-process DriftClient and then the subprocess.

````typescript name=server/drift-service.ts url=https://github.com/kynomatix/QuantumVault/blob/994941cabef77601d255595078bcce7742624782/server/drift-service.ts#L3362-L3378
export async function executePerpOrder(...) {
  ...
  // Use subprocess executor (fallback or when DriftClient not available)
  console.log('[Drift] Using subprocess executor for trade');
  ...
}
````

**Risk:** If Swift is integrated elsewhere, the core execution is still legacy-first. Any caller using `executePerpOrder` won’t hit Swift unless this is updated.

---

### 5) **PnL correctness depends on fill price but current flows use estimates**
The plan emphasizes accurate fill price handling, but the legacy executor uses oracle estimate, and some close flows use signal price, not actual fill.

````javascript name=server/drift-executor.mjs url=https://github.com/kynomatix/QuantumVault/blob/994941cabef77601d255595078bcce7742624782/server/drift-executor.mjs#L1395-L1403
const oracleData = driftClient.getOracleDataForPerpMarket(marketIndex);
fillPrice = oracleData?.price?.toNumber() / 1e6;
console.error(`[Executor] Fill price (oracle): $${fillPrice?.toFixed(6) || 'unknown'}`);
````

**Risk:** Swift returns real fill data, but existing storage/PnL flows are built around estimates. Mixing them could make Swift trades appear better/worse than legacy in analytics and profit-share.

---

### 6) **Subaccount subscription quirks could break Swift if it relies on the same client**
The plan assumes Swift signing uses the same client/key. The repo already flags issues with Drift client subscription reliability.

````text name=attached_assets/Pasted-Based-on-the-review-of-the-Swift-Protocol-Migration-Pla_1770614748906.txt url=https://github.com/kynomatix/QuantumVault/blob/994941cabef77601d255595078bcce7742624782/attached_assets/Pasted-Based-on-the-review-of-the-Swift-Protocol-Migration-Pla_1770614748906.txt#L13-L17
The Gap: The migration plan does not address whether the Swift execution path (which presumably uses a similar DriftClient setup) requires this same workaround. If the Swift client relies on the same broken subscription model to sign messages or verify accounts, the new integration will fail silently for any user using subaccounts (which appears to be a core feature).
````

**Risk:** Swift integration could inherit the same subscription/connection instability that prompted the subprocess path in the first place.

---

### 7) **Plan assumes subscriber routing already fixed; code shows multiple entry points**
The plan gates on subscriber routing being fixed, but the system uses multiple entry points (paused/expired/disabled/retry callbacks) which are not all obviously centralized in `executePerpOrder`.

````markdown name=docs/SUBSCRIBER_DIAGNOSTICS.md url=https://github.com/kynomatix/QuantumVault/blob/994941cabef77601d255595078bcce7742624782/docs/SUBSCRIBER_DIAGNOSTICS.md#L14-L26
| Path | When | Location |
|------|------|----------|
| Paused bot routing | Source bot is paused but published | Webhook handler, bot-active check |
| Execution disabled routing | Source wallet execution auth disabled but published | Webhook handler, executionEnabled check |
| Execution expired routing | Source wallet execution auth expired but published | Webhook handler, executionExpiresAt check |
| Close signal deferred | Successful close trade execution | After close response sent |
| Open signal deferred | Successful open trade execution | After open response sent |
| Retry callback | Successful retry execution | trade-retry-service.ts |
````

**Risk:** Swift integration that only touches `executePerpOrder` won’t cover all routing cases (particularly close flows). This can fragment behavior.

---

### 8) **Schema for advanced PnL/slippage tracking is not in place**
There’s a `pnl-refinement-plan` that expects `actualFillPrice`, `slippageBps`, etc., but they’re not in schema yet. Swift will likely surface this data and you may want to store it.

````markdown name=docs/pnl-refinement-plan.md url=https://github.com/kynomatix/QuantumVault/blob/994941cabef77601d255595078bcce7742624782/docs/pnl-refinement-plan.md#L216-L237
### Schema Modifications

```typescript
// Add to existing trades table
trades: {
  expectedPrice: varchar("expected_price"),
  actualFillPrice: varchar("actual_fill_price"),
  slippageAmount: varchar("slippage_amount"),
  slippageBps: integer("slippage_bps"), // basis points
}
```
````

**Risk:** If Swift fills include slippage and price improvement but you don’t store them, you’ll lose the main benefit of Swift in reporting/analytics.

---

## If you want me to keep going
I can continue with:
- **Manual trade path** vs webhook path gap checks
- **Subscriber routing + PnL path** consistency map
- **Exact places to inject Swift data into storage and UI**

Just say the word.